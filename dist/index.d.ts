/**
 * Shared game constants and utilities.
 *
 * This is the single source of truth for values that must match
 * between the client game (index.ts HTML) and the server replay engine.
 */
declare const CONTEST_COLS = 20;
declare const CONTEST_ROWS = 20;
declare function mulberry32(seed: number): () => number;
type GameInput = {
    tick: number;
    dx: number;
    dy: number;
    timer?: number;
};
type ReplayResult = {
    score: number;
    round: number;
    length: number;
};

/**
 * Headless Snake Replay Engine
 *
 * Deterministically replays a snake game given a seed and input log.
 * Uses the same constants and PRNG from core.ts that the client uses.
 * Game logic here must stay in sync with the inline game in index.ts.
 */

declare function replaySnakeGame({ seed, inputs, }: {
    seed: number;
    inputs: GameInput[];
}): ReplayResult;

declare const snakeGameHtml = "\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n    <meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n    <title>Snake Rounds</title>\n    <style>\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body {\n            width: 100%;\n            height: 100%;\n            overflow: hidden;\n            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n            color: #fff;\n            touch-action: none;\n            -webkit-touch-callout: none;\n            -webkit-user-select: none;\n            user-select: none;\n        }\n        #canvas {\n            display: block;\n            width: 100vw;\n            height: 100vh;\n        }\n        /* \u2500\u2500 HUD \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 */\n        #hud {\n            position: fixed;\n            top: 0; left: 0; right: 0;\n            z-index: 10;\n            padding: 52px 10px 0;\n            display: flex;\n            align-items: center;\n            justify-content: space-between;\n            height: auto;\n            pointer-events: none;\n        }\n        .embedded #hud { padding-top: 4px; }\n\n        .h-cell {\n            display: flex;\n            align-items: center;\n            gap: 4px;\n            background: rgba(0,0,0,0.5);\n            backdrop-filter: blur(6px);\n            -webkit-backdrop-filter: blur(6px);\n            border: 1px solid rgba(255,255,255,0.07);\n            border-radius: 8px;\n            padding: 3px 8px;\n            font-variant-numeric: tabular-nums;\n        }\n\n        .hud-left, .hud-right { display: flex; gap: 4px; flex-shrink: 0; }\n        .hud-center { display: flex; align-items: center; gap: 6px; }\n\n        .h-round { font-size: 11px; font-weight: 700; color: rgba(255,255,255,0.5); text-transform: uppercase; }\n        .h-round b { color: #fff; font-size: 12px; }\n        .h-len { font-size: 11px; font-weight: 600; color: rgba(255,255,255,0.6); }\n        .h-len b { color: #fff; }\n\n        .h-score-cell {\n            display: flex;\n            align-items: center;\n            gap: 6px;\n            background: linear-gradient(135deg, rgba(255,215,0,0.12), rgba(255,170,0,0.06));\n            border: 1px solid rgba(255,215,0,0.2);\n            backdrop-filter: blur(8px);\n            -webkit-backdrop-filter: blur(8px);\n            border-radius: 10px;\n            padding: 3px 14px;\n        }\n        .h-score {\n            font-size: 22px;\n            font-weight: 800;\n            color: #ffd700;\n            line-height: 1;\n            text-shadow: 0 0 10px rgba(255,200,0,0.35);\n            font-variant-numeric: tabular-nums;\n        }\n        .h-timer {\n            font-size: 14px;\n            font-weight: 700;\n            color: #34d399;\n            font-variant-numeric: tabular-nums;\n            line-height: 1;\n        }\n        .h-timer.warning { color: #fbbf24; }\n        .h-timer.danger { color: #f87171; animation: hud-pulse 0.5s infinite; }\n        .h-timer-sep { color: rgba(255,255,255,0.15); font-size: 14px; }\n        .h-speed {\n            font-size: 8px; font-weight: 700; letter-spacing: 0.05em;\n            text-transform: uppercase; color: rgba(255,255,255,0.35);\n            background: rgba(255,255,255,0.06); border-radius: 4px; padding: 1px 5px;\n        }\n\n        .h-icon { font-size: 10px; line-height: 1; }\n        .h-stat { font-size: 11px; font-weight: 700; color: #fff; }\n        .h-stat-dim { color: rgba(255,255,255,0.3); font-weight: 600; font-size: 11px; }\n\n        @keyframes hud-pulse {\n            0%, 100% { opacity: 1; }\n            50% { opacity: 0.4; }\n        }\n        #howToPlay {\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: linear-gradient(135deg, #2d3436 0%, #1a1a2e 100%);\n            padding: 30px 25px;\n            border-radius: 24px;\n            text-align: center;\n            z-index: 30;\n            box-shadow: 0 20px 60px rgba(0,0,0,0.5);\n            border: 1px solid rgba(255,255,255,0.1);\n            max-width: 320px;\n            width: 90%;\n            display: none;\n        }\n        #howToPlay h2 {\n            font-size: 28px;\n            margin-bottom: 20px;\n            background: linear-gradient(135deg, #2ecc71, #27ae60);\n            -webkit-background-clip: text;\n            -webkit-text-fill-color: transparent;\n        }\n        .instructions {\n            text-align: left;\n            margin-bottom: 24px;\n        }\n        .instruction-item {\n            display: flex;\n            align-items: center;\n            gap: 12px;\n            margin: 10px 0;\n            font-size: 14px;\n            color: rgba(255,255,255,0.85);\n        }\n        .instruction-icon {\n            width: 28px;\n            height: 28px;\n            border-radius: 8px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            font-size: 14px;\n            flex-shrink: 0;\n        }\n        .icon-coconut { background: #8B4513; border-radius: 50%; }\n        .icon-speed { background: linear-gradient(135deg, #2ecc71, #27ae60); border-radius: 50%; }\n        .icon-ultra { background: linear-gradient(135deg, #3498db, #2980b9); border-radius: 50%; }\n        .icon-ice { background: linear-gradient(135deg, #74b9ff, #0984e3); }\n        .icon-coin { background: linear-gradient(135deg, #f1c40f, #f39c12); border-radius: 50%; }\n        .icon-barrier { background: linear-gradient(135deg, #e74c3c, #c0392b); }\n        #howToPlay button {\n            background: linear-gradient(135deg, #2ecc71, #27ae60);\n            border: none;\n            color: #fff;\n            padding: 16px 48px;\n            font-size: 18px;\n            font-weight: 700;\n            border-radius: 30px;\n            cursor: pointer;\n            box-shadow: 0 8px 24px rgba(46, 204, 113, 0.4);\n            transition: transform 0.2s, box-shadow 0.2s;\n        }\n        #howToPlay button:active {\n            transform: scale(0.95);\n        }\n        #message {\n            position: fixed;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            background: linear-gradient(135deg, #2d3436 0%, #1a1a2e 100%);\n            padding: 30px;\n            border-radius: 24px;\n            text-align: center;\n            z-index: 30;\n            box-shadow: 0 20px 60px rgba(0,0,0,0.5);\n            border: 1px solid rgba(255,255,255,0.1);\n            display: none;\n        }\n        #message h2 { font-size: 24px; margin-bottom: 10px; }\n        #message p { color: rgba(255,255,255,0.7); margin-bottom: 20px; }\n        #message button {\n            background: linear-gradient(135deg, #f39c12, #e67e22);\n            border: none;\n            color: #fff;\n            padding: 14px 40px;\n            font-size: 16px;\n            font-weight: 700;\n            border-radius: 25px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"hud\">\n        <div class=\"hud-left\">\n            <div class=\"h-cell\"><span class=\"h-round\">R<b id=\"round\">1</b></span></div>\n            <div class=\"h-cell\"><span class=\"h-len\">\uD83D\uDC0D <b id=\"length\">3</b><span class=\"h-stat-dim\">/<span id=\"target\">11</span></span></span></div>\n        </div>\n        <div class=\"hud-center\">\n            <div class=\"h-score-cell\">\n                <span class=\"h-score\" id=\"score\">0</span>\n                <span class=\"h-timer-sep\">|</span>\n                <span class=\"h-timer\" id=\"timer\">60</span>\n                <span class=\"h-speed\" id=\"speed\">NORMAL</span>\n            </div>\n        </div>\n        <div class=\"hud-right\">\n            <div class=\"h-cell\"><span class=\"h-icon\">\uD83D\uDCB0</span><span class=\"h-stat\" id=\"coins\">0</span><span class=\"h-stat-dim\">/50</span></div>\n            <div class=\"h-cell\"><span class=\"h-icon\">\u2764\uFE0F</span><span class=\"h-stat\" id=\"lives\">0</span></div>\n        </div>\n    </div>\n    <canvas id=\"canvas\"></canvas>\n    <div id=\"howToPlay\">\n        <h2>\uD83D\uDC0D Snake Rounds</h2>\n        <div class=\"instructions\">\n            <div class=\"instruction-item\"><span class=\"instruction-icon icon-coconut\">\uD83E\uDD65</span> Brown = Grow (normal)</div>\n            <div class=\"instruction-item\"><span class=\"instruction-icon icon-speed\">\u26A1</span> Green = Speed boost</div>\n            <div class=\"instruction-item\"><span class=\"instruction-icon icon-ultra\">\uD83D\uDC8E</span> Blue = EXTREME speed</div>\n            <div class=\"instruction-item\"><span class=\"instruction-icon icon-ice\">\u2744\uFE0F</span> Ice = Slow down</div>\n            <div class=\"instruction-item\"><span class=\"instruction-icon icon-coin\">\uD83D\uDCB0</span> Coins = 50 for extra life</div>\n            <div class=\"instruction-item\"><span class=\"instruction-icon icon-barrier\">\u26D4</span> Barriers = Avoid! (Round 2+)</div>\n        </div>\n        <button onclick=\"startGame()\">START GAME</button>\n    </div>\n    <div id=\"message\">\n        <h2 id=\"msg-title\">Round Complete!</h2>\n        <p id=\"msg-text\">Get ready for the next round</p>\n        <button onclick=\"nextAction()\">Continue</button>\n    </div>\n\n    <script>\n        var canvas = document.getElementById('canvas');\n        var ctx = canvas.getContext('2d');\n\n        var isEmbedded = (window.parent && window.parent !== window);\n        if (isEmbedded) document.body.classList.add('embedded');\n\n        var GRID, COLS, ROWS, TOP_OFFSET, BOTTOM_OFFSET, X_OFFSET;\n        var snake, direction, nextDirection, food, barriers;\n        var round, targetLength, gameOver, roundComplete, gameLoop;\n        var gameSpeed, baseSpeed, foodType, icePowerUp;\n        var coins, lives, fallingCoins, totalScore;\n        var roundTimer, roundTimeLimit, timerInterval;\n        var gameStarted = false;\n        var contestConfig = null;\n        var sessionStartTime = null;\n\n        // Deterministic replay support\n        var sessionId = null;\n        var sessionSeed = null;\n        var rng = Math.random; // default; replaced with seeded PRNG in contest mode\n        var tickCount = 0;\n        var inputLog = [];\n\n        // Mulberry32 seeded PRNG (deterministic)\n        function mulberry32(seed) {\n            var s = seed | 0;\n            return function() {\n                s = (s + 0x6D2B79F5) | 0;\n                var t = Math.imul(s ^ (s >>> 15), 1 | s);\n                t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;\n                return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n            };\n        }\n\n        // Fixed contest grid \u2014 must match CONTEST_COLS/CONTEST_ROWS in core.ts\n        var CONTEST_COLS = 20;\n        var CONTEST_ROWS = 20;\n\n        function resize() {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            var headerPx = isEmbedded ? 44 : 130;\n            var bottomPx = 20;\n            if (sessionSeed !== null) {\n                // Contest mode: fit fixed grid to screen\n                COLS = CONTEST_COLS;\n                ROWS = CONTEST_ROWS;\n                // Calculate GRID so that header + game area fit within canvas\n                // TOP_OFFSET (in cells) = ceil(headerPx / GRID), so total height =\n                // ceil(headerPx/GRID)*GRID + ROWS*GRID. We solve for GRID:\n                // (headerPx + ROWS*GRID + bottomPx) <= canvas.height\n                // GRID <= (canvas.height - headerPx - bottomPx) / ROWS\n                var availW = canvas.width;\n                GRID = Math.floor(Math.min(availW / COLS, (canvas.height - headerPx - bottomPx) / ROWS));\n                TOP_OFFSET = Math.ceil(headerPx / GRID);\n                // Recheck: if TOP_OFFSET*GRID + ROWS*GRID > canvas.height, shrink GRID\n                while (TOP_OFFSET * GRID + ROWS * GRID > canvas.height && GRID > 5) {\n                    GRID--;\n                    TOP_OFFSET = Math.ceil(headerPx / GRID);\n                }\n                BOTTOM_OFFSET = 0;\n                X_OFFSET = Math.floor((canvas.width - COLS * GRID) / 2);\n            } else {\n                GRID = Math.floor(Math.min(canvas.width, canvas.height) / 20);\n                TOP_OFFSET = Math.ceil(headerPx / GRID);\n                BOTTOM_OFFSET = Math.ceil(bottomPx / GRID);\n                COLS = Math.floor(canvas.width / GRID);\n                ROWS = Math.floor(canvas.height / GRID) - TOP_OFFSET - BOTTOM_OFFSET;\n                X_OFFSET = 0;\n            }\n            if (snake && snake.length > 0) draw();\n        }\n        window.addEventListener('resize', resize);\n        resize();\n\n        function init() {\n            document.getElementById('howToPlay').style.display = 'block';\n        }\n\n        var waitingForSeed = false;\n\n        function startGame() {\n            document.getElementById('howToPlay').style.display = 'none';\n            gameStarted = true;\n            round = 1;\n            coins = 0;\n            lives = 0;\n            totalScore = 0;\n            fallingCoins = [];\n            tickCount = 0;\n            inputLog = [];\n            sessionStartTime = new Date().toISOString();\n            postSessionMessage('SESSION_START', { startTime: sessionStartTime });\n            // In contest/embedded mode, wait for SESSION_SEED before starting\n            if (contestConfig || isEmbedded) {\n                waitingForSeed = true;\n                return;\n            }\n            rng = Math.random;\n            startRound();\n        }\n\n        function startRound() {\n            // Every 3rd round is a \"growth round\"\n            var isGrowthRound = round % 3 === 0;\n            // Growth rounds: start small, grow long. Other rounds: keep current length\n            var startLength = (round === 1 || isGrowthRound) ? 3 : snake.length;\n            snake = [];\n            var startX = Math.floor(COLS / 2);\n            var startY = Math.floor(ROWS / 2);\n            for (var i = 0; i < startLength; i++) {\n                snake.push({ x: startX - i, y: startY });\n            }\n            direction = { x: 1, y: 0 };\n            nextDirection = { x: 1, y: 0 };\n            // Growth rounds have high target length, others are normal\n            targetLength = isGrowthRound ? 25 + (round * 2) : startLength + 5 + (round * 3);\n            barriers = generateBarriers();\n            gameOver = false;\n            roundComplete = false;\n            baseSpeed = 100;\n            gameSpeed = baseSpeed;\n            icePowerUp = null;\n            // Growth rounds get longer time\n            roundTimeLimit = isGrowthRound ? 90 : Math.max(30, 60 - (round - 1) * 5);\n            roundTimer = roundTimeLimit;\n            startTimer();\n            placeFood();\n            updateUI();\n            startGameLoop();\n        }\n\n        function startTimer() {\n            if (timerInterval) clearInterval(timerInterval);\n            timerInterval = setInterval(function() {\n                if (gameOver || roundComplete) return;\n                roundTimer--;\n                inputLog.push({ tick: tickCount, dx: 0, dy: 0, timer: 1 });\n                updateUI();\n                if (roundTimer <= 0) timeUp();\n            }, 1000);\n        }\n\n        function timeUp() {\n            if (lives > 0) {\n                lives--;\n                roundTimer = roundTimeLimit;\n                updateUI();\n                return;\n            }\n            gameOver = true;\n            clearInterval(gameLoop);\n            clearInterval(timerInterval);\n            var finalScore = totalScore + snake.length;\n            postSessionMessage('SESSION_END', {\n                score: finalScore,\n                round: round,\n                length: snake.length,\n                targetLength: targetLength,\n                startTime: sessionStartTime,\n                endTime: new Date().toISOString(),\n                sessionId: sessionId,\n                inputs: inputLog\n            });\n            showMessage(\"Time's Up!\", 'Score: ' + finalScore + ' \u2022 Round ' + round, 'Try Again');\n        }\n\n        function startGameLoop() {\n            if (gameLoop) clearInterval(gameLoop);\n            gameLoop = setInterval(update, gameSpeed);\n        }\n\n        function changeSpeed(newSpeed) {\n            gameSpeed = Math.max(60, Math.min(150, newSpeed));\n            startGameLoop();\n            updateUI();\n        }\n\n        function generateBarriers() {\n            var b = [];\n            if (round < 2) return b;\n            var numBarriers = Math.min(1 + round * 2, 12);\n            var snakeStartX = Math.floor(COLS / 2);\n            var snakeStartY = Math.floor(ROWS / 2);\n\n            for (var i = 0; i < numBarriers; i++) {\n                var isHorizontal = rng() > 0.5;\n                var length = 3 + Math.floor(rng() * (round + 2));\n                var startX = Math.floor(rng() * (COLS - length - 4)) + 2;\n                var startY = Math.floor(rng() * (ROWS - length - 4)) + 2;\n\n                for (var j = 0; j < length; j++) {\n                    var bx = isHorizontal ? startX + j : startX;\n                    var by = isHorizontal ? startY : startY + j;\n                    if (Math.abs(bx - snakeStartX) > 5 || Math.abs(by - snakeStartY) > 3) {\n                        b.push({ x: bx, y: by });\n                    }\n                }\n            }\n            return b;\n        }\n\n        function placeFood() {\n            var valid = false;\n            var attempts = 0;\n            while (!valid && attempts < 1000) {\n                food = {\n                    x: Math.floor(rng() * COLS),\n                    y: Math.floor(rng() * ROWS)\n                };\n                valid = !snake.some(function(s) { return s.x === food.x && s.y === food.y; }) &&\n                        !barriers.some(function(b) { return b.x === food.x && b.y === food.y; });\n                attempts++;\n            }\n            // Every 3rd round is a \"growth round\" - only normal food, no speed modifiers\n            var isGrowthRound = round % 3 === 0;\n            if (isGrowthRound) {\n                foodType = 'normal';\n            } else {\n                var roll = rng();\n                if (roll < 0.15) foodType = 'ultra';\n                else if (roll < 0.40) foodType = 'speed';\n                else foodType = 'normal';\n            }\n\n            // No ice power-ups on growth rounds\n            if (!icePowerUp && rng() < 0.25 && !isGrowthRound) {\n                placeIcePowerUp();\n            }\n        }\n\n        function placeIcePowerUp() {\n            var valid = false;\n            var attempts = 0;\n            while (!valid && attempts < 500) {\n                icePowerUp = {\n                    x: Math.floor(rng() * COLS),\n                    y: Math.floor(rng() * ROWS)\n                };\n                valid = !snake.some(function(s) { return s.x === icePowerUp.x && s.y === icePowerUp.y; }) &&\n                        !barriers.some(function(b) { return b.x === icePowerUp.x && b.y === icePowerUp.y; }) &&\n                        !(food.x === icePowerUp.x && food.y === icePowerUp.y);\n                attempts++;\n            }\n        }\n\n        function spawnCoin() {\n            fallingCoins.push({\n                x: Math.floor(rng() * COLS),\n                y: 0,\n                fallProgress: 0\n            });\n        }\n\n        function update() {\n            if (gameOver || roundComplete) return;\n\n            tickCount++;\n            if (rng() < 0.03) spawnCoin();\n\n            fallingCoins.forEach(function(c) { c.fallProgress += 0.2; });\n            fallingCoins = fallingCoins.filter(function(c) { return c.fallProgress < ROWS; });\n\n            var head = snake[0];\n            var newCoins = [];\n            fallingCoins.forEach(function(coin) {\n                var coinY = Math.floor(coin.fallProgress);\n                if (coin.x === head.x && Math.abs(coinY - head.y) <= 1) {\n                    coins++;\n                    if (coins >= 50) { coins -= 50; lives++; }\n                    updateUI();\n                } else {\n                    newCoins.push(coin);\n                }\n            });\n            fallingCoins = newCoins;\n\n            direction = nextDirection;\n            var newHead = { x: head.x + direction.x, y: head.y + direction.y };\n\n            if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) {\n                endGame(); return;\n            }\n            if (snake.some(function(s) { return s.x === newHead.x && s.y === newHead.y; })) {\n                endGame(); return;\n            }\n            if (barriers.some(function(b) { return b.x === newHead.x && b.y === newHead.y; })) {\n                endGame(); return;\n            }\n\n            snake.unshift(newHead);\n\n            if (icePowerUp && newHead.x === icePowerUp.x && newHead.y === icePowerUp.y) {\n                changeSpeed(gameSpeed + 25);\n                icePowerUp = null;\n            }\n\n            if (newHead.x === food.x && newHead.y === food.y) {\n                // Speed boosts are fixed, not cumulative\n                if (foodType === 'ultra') changeSpeed(baseSpeed - 15);\n                else if (foodType === 'speed') changeSpeed(baseSpeed - 10);\n                placeFood();\n                if (snake.length >= targetLength) completeRound();\n            } else {\n                snake.pop();\n            }\n\n            updateUI();\n            draw();\n        }\n\n        var animFrame = 0;\n        function draw() {\n            animFrame++;\n            var yOffset = TOP_OFFSET * GRID;\n            var pulse = Math.sin(animFrame * 0.1) * 0.5 + 0.5;\n\n            // Background gradient\n            var gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n            gradient.addColorStop(0, '#0f0f23');\n            gradient.addColorStop(0.5, '#1a1a3e');\n            gradient.addColorStop(1, '#0d1b2a');\n            ctx.fillStyle = gradient;\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n            // Game area border\n            var xOff = X_OFFSET || 0;\n            var gameAreaX = xOff;\n            var gameAreaY = yOffset;\n            var gameAreaW = COLS * GRID;\n            var gameAreaH = ROWS * GRID;\n            ctx.strokeStyle = 'rgba(255,255,255,0.3)';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(gameAreaX + 1, gameAreaY + 1, gameAreaW - 2, gameAreaH - 2);\n            // Glowing edge effect\n            ctx.shadowColor = '#00ffff';\n            ctx.shadowBlur = 10;\n            ctx.strokeStyle = 'rgba(0,255,255,0.2)';\n            ctx.strokeRect(gameAreaX + 1, gameAreaY + 1, gameAreaW - 2, gameAreaH - 2);\n            ctx.shadowBlur = 0;\n\n            // Barriers - glowing red crystals\n            barriers.forEach(function(b) {\n                var bx = xOff + b.x * GRID + GRID/2;\n                var by = yOffset + b.y * GRID + GRID/2;\n                var bGrad = ctx.createRadialGradient(bx, by, 0, bx, by, GRID/2);\n                bGrad.addColorStop(0, '#ff6b6b');\n                bGrad.addColorStop(0.6, '#e74c3c');\n                bGrad.addColorStop(1, '#c0392b');\n                ctx.fillStyle = bGrad;\n                ctx.shadowColor = '#ff0000';\n                ctx.shadowBlur = 8 + pulse * 4;\n                ctx.beginPath();\n                ctx.moveTo(bx, by - GRID/2 + 3);\n                ctx.lineTo(bx + GRID/2 - 3, by);\n                ctx.lineTo(bx, by + GRID/2 - 3);\n                ctx.lineTo(bx - GRID/2 + 3, by);\n                ctx.closePath();\n                ctx.fill();\n                ctx.shadowBlur = 0;\n            });\n\n            // Snake body with gradient and glow\n            for (var i = snake.length - 1; i >= 0; i--) {\n                var seg = snake[i];\n                var segX = xOff + seg.x * GRID + GRID/2;\n                var segY = yOffset + seg.y * GRID + GRID/2;\n                var progress = i / snake.length;\n                var radius = GRID/2 - 1 - (progress * 3);\n\n                // Body gradient - cyan to purple\n                var snakeGrad = ctx.createRadialGradient(segX - 2, segY - 2, 0, segX, segY, radius);\n                if (i === 0) {\n                    snakeGrad.addColorStop(0, '#00ff88');\n                    snakeGrad.addColorStop(0.5, '#00d4aa');\n                    snakeGrad.addColorStop(1, '#00a080');\n                    ctx.shadowColor = '#00ff88';\n                    ctx.shadowBlur = 20;\n                } else {\n                    var hue = 160 + progress * 40;\n                    var sat = 80 - progress * 30;\n                    var light = 55 - progress * 20;\n                    snakeGrad.addColorStop(0, 'hsl(' + hue + ',' + sat + '%,' + (light + 15) + '%)');\n                    snakeGrad.addColorStop(1, 'hsl(' + hue + ',' + sat + '%,' + light + '%)');\n                    ctx.shadowBlur = 0;\n                }\n\n                ctx.fillStyle = snakeGrad;\n                ctx.beginPath();\n                ctx.arc(segX, segY, radius, 0, Math.PI * 2);\n                ctx.fill();\n\n                // Shine effect\n                if (i < snake.length / 3) {\n                    ctx.fillStyle = 'rgba(255,255,255,0.3)';\n                    ctx.beginPath();\n                    ctx.arc(segX - radius/3, segY - radius/3, radius/4, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                ctx.shadowBlur = 0;\n\n                // Snake head details\n                if (i === 0) {\n                    var eyeOff = GRID / 4;\n                    var eyeX1 = segX - eyeOff + direction.x * 4;\n                    var eyeY1 = segY - eyeOff * direction.x + direction.y * 4;\n                    var eyeX2 = segX + eyeOff + direction.x * 4;\n                    var eyeY2 = segY + eyeOff * direction.x + direction.y * 4;\n                    if (direction.y !== 0) {\n                        eyeX1 = segX - eyeOff;\n                        eyeX2 = segX + eyeOff;\n                        eyeY1 = segY + direction.y * 3;\n                        eyeY2 = segY + direction.y * 3;\n                    }\n                    // Eye whites\n                    ctx.fillStyle = '#fff';\n                    ctx.beginPath();\n                    ctx.arc(eyeX1, eyeY1, 5, 0, Math.PI * 2);\n                    ctx.arc(eyeX2, eyeY2, 5, 0, Math.PI * 2);\n                    ctx.fill();\n                    // Pupils\n                    ctx.fillStyle = '#000';\n                    ctx.beginPath();\n                    ctx.arc(eyeX1 + direction.x, eyeY1 + direction.y, 2.5, 0, Math.PI * 2);\n                    ctx.arc(eyeX2 + direction.x, eyeY2 + direction.y, 2.5, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n            }\n\n            // Food - different styles based on type\n            var fx = xOff + food.x * GRID + GRID/2;\n            var fy = yOffset + food.y * GRID + GRID/2;\n            var fr = GRID/2 - 2 + pulse * 2;\n\n            if (foodType === 'ultra') {\n                // Diamond/crystal effect\n                var ultraGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fr);\n                ultraGrad.addColorStop(0, '#00ffff');\n                ultraGrad.addColorStop(0.5, '#0099ff');\n                ultraGrad.addColorStop(1, '#0066cc');\n                ctx.fillStyle = ultraGrad;\n                ctx.shadowColor = '#00ffff';\n                ctx.shadowBlur = 25 + pulse * 10;\n                ctx.beginPath();\n                ctx.moveTo(fx, fy - fr);\n                ctx.lineTo(fx + fr, fy);\n                ctx.lineTo(fx, fy + fr);\n                ctx.lineTo(fx - fr, fy);\n                ctx.closePath();\n                ctx.fill();\n                // Inner shine\n                ctx.fillStyle = 'rgba(255,255,255,0.5)';\n                ctx.beginPath();\n                ctx.moveTo(fx, fy - fr/2);\n                ctx.lineTo(fx + fr/3, fy);\n                ctx.lineTo(fx, fy + fr/3);\n                ctx.lineTo(fx - fr/3, fy);\n                ctx.closePath();\n                ctx.fill();\n            } else if (foodType === 'speed') {\n                // Purple energy orb\n                var speedGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, fr);\n                speedGrad.addColorStop(0, '#ff66ff');\n                speedGrad.addColorStop(0.5, '#cc33ff');\n                speedGrad.addColorStop(1, '#9900cc');\n                ctx.fillStyle = speedGrad;\n                ctx.shadowColor = '#cc33ff';\n                ctx.shadowBlur = 20 + pulse * 8;\n                ctx.beginPath();\n                ctx.arc(fx, fy, fr, 0, Math.PI * 2);\n                ctx.fill();\n                // Lightning symbol\n                ctx.fillStyle = '#fff';\n                ctx.font = 'bold ' + (GRID * 0.6) + 'px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText('\u26A1', fx, fy);\n            } else {\n                // Apple/fruit style\n                var foodGrad = ctx.createRadialGradient(fx - 3, fy - 3, 0, fx, fy, fr);\n                foodGrad.addColorStop(0, '#ff6b6b');\n                foodGrad.addColorStop(0.7, '#ee5253');\n                foodGrad.addColorStop(1, '#b33939');\n                ctx.fillStyle = foodGrad;\n                ctx.shadowColor = '#ff0000';\n                ctx.shadowBlur = 12;\n                ctx.beginPath();\n                ctx.arc(fx, fy, fr, 0, Math.PI * 2);\n                ctx.fill();\n                // Shine\n                ctx.fillStyle = 'rgba(255,255,255,0.4)';\n                ctx.beginPath();\n                ctx.arc(fx - fr/3, fy - fr/3, fr/3, 0, Math.PI * 2);\n                ctx.fill();\n                // Stem\n                ctx.fillStyle = '#27ae60';\n                ctx.fillRect(fx - 2, fy - fr - 4, 4, 6);\n            }\n            ctx.shadowBlur = 0;\n\n            // Ice power-up - snowflake crystal\n            if (icePowerUp) {\n                var ix = xOff + icePowerUp.x * GRID + GRID/2;\n                var iy = yOffset + icePowerUp.y * GRID + GRID/2;\n                var ir = GRID/2;\n                var iceGrad = ctx.createRadialGradient(ix, iy, 0, ix, iy, ir);\n                iceGrad.addColorStop(0, '#ffffff');\n                iceGrad.addColorStop(0.5, '#74b9ff');\n                iceGrad.addColorStop(1, '#0984e3');\n                ctx.fillStyle = iceGrad;\n                ctx.shadowColor = '#74b9ff';\n                ctx.shadowBlur = 15 + pulse * 5;\n                // Hexagon shape\n                ctx.beginPath();\n                for (var hi = 0; hi < 6; hi++) {\n                    var angle = (hi * Math.PI / 3) - Math.PI / 2;\n                    var hx = ix + Math.cos(angle) * (ir - 2);\n                    var hy = iy + Math.sin(angle) * (ir - 2);\n                    if (hi === 0) ctx.moveTo(hx, hy);\n                    else ctx.lineTo(hx, hy);\n                }\n                ctx.closePath();\n                ctx.fill();\n                ctx.fillStyle = '#fff';\n                ctx.font = (GRID * 0.5) + 'px Arial';\n                ctx.textAlign = 'center';\n                ctx.textBaseline = 'middle';\n                ctx.fillText('\u2744', ix, iy);\n                ctx.shadowBlur = 0;\n            }\n\n            // Falling coins - spinning gold coins\n            fallingCoins.forEach(function(coin) {\n                var coinX = xOff + coin.x * GRID + GRID/2;\n                var coinY = yOffset + coin.fallProgress * GRID + GRID/2;\n                var coinR = GRID/3;\n                var spin = Math.abs(Math.sin(animFrame * 0.15 + coin.x));\n                var coinGrad = ctx.createRadialGradient(coinX - 2, coinY - 2, 0, coinX, coinY, coinR);\n                coinGrad.addColorStop(0, '#fff7a1');\n                coinGrad.addColorStop(0.5, '#ffd700');\n                coinGrad.addColorStop(1, '#b8860b');\n                ctx.fillStyle = coinGrad;\n                ctx.shadowColor = '#ffd700';\n                ctx.shadowBlur = 12;\n                ctx.beginPath();\n                ctx.ellipse(coinX, coinY, coinR * spin, coinR, 0, 0, Math.PI * 2);\n                ctx.fill();\n                if (spin > 0.3) {\n                    ctx.fillStyle = '#b8860b';\n                    ctx.font = 'bold ' + (coinR) + 'px Arial';\n                    ctx.textAlign = 'center';\n                    ctx.textBaseline = 'middle';\n                    ctx.fillText('$', coinX, coinY + 1);\n                }\n                ctx.shadowBlur = 0;\n            });\n        }\n\n        function updateUI() {\n            document.getElementById('round').textContent = round;\n            document.getElementById('length').textContent = snake.length;\n            document.getElementById('target').textContent = targetLength;\n            document.getElementById('score').textContent = totalScore + snake.length;\n            document.getElementById('coins').textContent = coins;\n            document.getElementById('lives').textContent = lives;\n            document.getElementById('timer').textContent = roundTimer;\n\n            var timerEl = document.getElementById('timer');\n            timerEl.className = 'h-timer';\n            if (roundTimer <= 10) timerEl.className += ' danger';\n            else if (roundTimer <= 20) timerEl.className += ' warning';\n\n            var speedLabel = 'NORMAL';\n            if (gameSpeed <= 55) speedLabel = 'INSANE';\n            else if (gameSpeed <= 70) speedLabel = 'FAST';\n            else if (gameSpeed <= 85) speedLabel = 'QUICK';\n            else if (gameSpeed >= 125) speedLabel = 'SLOW';\n            document.getElementById('speed').textContent = speedLabel;\n        }\n\n        function completeRound() {\n            roundComplete = true;\n            totalScore += snake.length;\n            clearInterval(gameLoop);\n            clearInterval(timerInterval);\n            showMessage('Round ' + round + ' Complete!', 'Score: ' + totalScore + ' \u2022 Length: ' + snake.length, 'Next Round \u2192');\n        }\n\n        function endGame() {\n            if (lives > 0) {\n                lives--;\n                respawn();\n                return;\n            }\n            gameOver = true;\n            clearInterval(gameLoop);\n            clearInterval(timerInterval);\n            var finalScore = totalScore + snake.length;\n            postSessionMessage('SESSION_END', {\n                score: finalScore,\n                round: round,\n                length: snake.length,\n                targetLength: targetLength,\n                startTime: sessionStartTime,\n                endTime: new Date().toISOString(),\n                sessionId: sessionId,\n                inputs: inputLog\n            });\n            showMessage('Game Over!', 'Score: ' + finalScore + ' \u2022 Round ' + round, 'Play Again');\n        }\n\n        function respawn() {\n            var currentLength = snake.length;\n            snake = [];\n            var startX = Math.floor(COLS / 2);\n            var startY = Math.floor(ROWS / 2);\n            for (var i = 0; i < currentLength; i++) {\n                snake.push({ x: startX - i, y: startY });\n            }\n            direction = { x: 1, y: 0 };\n            nextDirection = { x: 1, y: 0 };\n            updateUI();\n        }\n\n        function showMessage(title, text, btnText) {\n            document.getElementById('msg-title').textContent = title;\n            document.getElementById('msg-text').textContent = text;\n            document.getElementById('message').querySelector('button').textContent = btnText;\n            document.getElementById('message').style.display = 'block';\n        }\n\n        function nextAction() {\n            document.getElementById('message').style.display = 'none';\n            if (gameOver) {\n                round = 1;\n                snake = [];\n                coins = 0;\n                lives = 0;\n                totalScore = 0;\n                fallingCoins = [];\n                tickCount = 0;\n                inputLog = [];\n                sessionStartTime = new Date().toISOString();\n                postSessionMessage('SESSION_START', { startTime: sessionStartTime });\n                // Wait for new SESSION_SEED before starting if in contest/embedded mode\n                if (contestConfig || isEmbedded) return;\n            } else {\n                round++;\n            }\n            startRound();\n        }\n\n        // Touch controls\n        var touchStartX = 0, touchStartY = 0, touchStartTime = 0;\n\n        canvas.addEventListener('touchstart', function(e) {\n            touchStartX = e.touches[0].clientX;\n            touchStartY = e.touches[0].clientY;\n            touchStartTime = Date.now();\n            e.preventDefault();\n        }, { passive: false });\n\n        canvas.addEventListener('touchend', function(e) {\n            // Allow tap to advance past round-complete or game-over screens\n            if (roundComplete || gameOver) {\n                nextAction();\n                return;\n            }\n            if (!gameStarted) return;\n            var dx = e.changedTouches[0].clientX - touchStartX;\n            var dy = e.changedTouches[0].clientY - touchStartY;\n            var duration = Date.now() - touchStartTime;\n\n            if (duration < 400 && (Math.abs(dx) > 20 || Math.abs(dy) > 20)) {\n                var newDir = null;\n                if (Math.abs(dx) > Math.abs(dy)) {\n                    if (dx > 0 && direction.x !== -1) newDir = {x: 1, y: 0};\n                    else if (dx < 0 && direction.x !== 1) newDir = {x: -1, y: 0};\n                } else {\n                    if (dy > 0 && direction.y !== -1) newDir = {x: 0, y: 1};\n                    else if (dy < 0 && direction.y !== 1) newDir = {x: 0, y: -1};\n                }\n                if (newDir) {\n                    nextDirection = newDir;\n                    inputLog.push({ tick: tickCount, dx: newDir.x, dy: newDir.y });\n                    update();\n                    startGameLoop();\n                }\n            }\n        }, { passive: false });\n\n        document.addEventListener('keydown', function(e) {\n            // Allow right arrow to advance past round-complete or game-over screens\n            if (e.key === 'ArrowRight' && (roundComplete || gameOver)) {\n                nextAction();\n                e.preventDefault();\n                return;\n            }\n            if (!gameStarted || gameOver || roundComplete) return;\n            var newDir = null;\n            if (e.key === 'ArrowUp' && direction.y !== 1) newDir = {x: 0, y: -1};\n            if (e.key === 'ArrowDown' && direction.y !== -1) newDir = {x: 0, y: 1};\n            if (e.key === 'ArrowLeft' && direction.x !== 1) newDir = {x: -1, y: 0};\n            if (e.key === 'ArrowRight' && direction.x !== -1) newDir = {x: 1, y: 0};\n            if (newDir) {\n                nextDirection = newDir;\n                inputLog.push({ tick: tickCount, dx: newDir.x, dy: newDir.y });\n                update();\n                startGameLoop();\n            }\n            e.preventDefault();\n        });\n\n        function postSessionMessage(type, data) {\n            var msg = { type: type };\n            if (contestConfig) {\n                msg.gameID = contestConfig.gameID;\n                msg.username = contestConfig.username;\n                msg.walletAddress = contestConfig.walletAddress;\n            }\n            for (var key in data) { msg[key] = data[key]; }\n            console.log('[Snake]', type, msg);\n            try {\n                if (window.parent && window.parent !== window) {\n                    window.parent.postMessage(msg, '*');\n                }\n                if (window.ReactNativeWebView) {\n                    window.ReactNativeWebView.postMessage(JSON.stringify(msg));\n                }\n            } catch(e) {}\n        }\n\n        window.addEventListener('message', function(e) {\n            if (e.data && e.data.type === 'CONTEST_CONFIG') {\n                contestConfig = {\n                    gameID: e.data.gameID,\n                    username: e.data.username,\n                    walletAddress: e.data.walletAddress\n                };\n            }\n            if (e.data && e.data.type === 'SESSION_SEED') {\n                sessionId = e.data.sessionId;\n                sessionSeed = e.data.seed;\n                rng = mulberry32(sessionSeed);\n                resize(); // recompute grid with fixed contest dims\n                // Start the round if game is waiting for seed\n                if (waitingForSeed || (gameStarted && gameOver)) {\n                    waitingForSeed = false;\n                    startRound();\n                }\n            }\n        });\n\n        init();\n    </script>\n</body>\n</html>\n";

export { CONTEST_COLS, CONTEST_ROWS, type GameInput, type ReplayResult, mulberry32, replaySnakeGame, snakeGameHtml };
